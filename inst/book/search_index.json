[["index.html", "Building Web Apps with R Shiny Overview 0.1 Example Apps 0.2 Code Horizons Course (27-30 July 2021) 0.3 Computing 0.4 Who Should Register? 0.5 Further Resources 0.6 Glossary", " Building Web Apps with R Shiny Lisa DeBruine 2021-07-11 Overview Shiny apps let you make web applications that do anything you can code in R. For example, you can share your data analysis in a dynamic way with people who don’t use R, collect and visualize data, or even make data aRt. While there is a wealth of material available on the internet to help you get started with Shiny, it can be difficult to see how everything fits together. This class will take a predominantly live coding approach, rather than a lecture-only approach, so you can code along with the instructor and deal with the inevitable bugs and roadblocks together. This class will teach you the basics of Shiny app programming, giving you skills that will form the basis of almost any app you want to build. By the end of the class, you will have created a custom app that collects and saves data, allows users to dynamically visualize the data, and produces downloadable reports. 0.1 Example Apps The following are some diverse examples of Shiny apps that the instructor has made. Plot Demo Simulate data from a 2×2 factorial design and visualize it with 6 different plot styles. Simulating for LMEM companion to Understanding mixed effects models through data simulation (DeBruine &amp; Barr, AMPPS 2021) Scienceverse is an ambitious (but in-progress) app for creating machine-readable descriptions of studies and human-readable summaries. Word Cloud Create a word cloud from text and customize its appearance. Created during the live-coding event at Hack Your Data Beautiful. Figure 0.1: Word Cloud App 0.2 Code Horizons Course (27-30 July 2021) Starting July 27, we are offering this seminar as a 4-day synchronous*, remote workshop for the first time. Each day will consist of a 3-hour live lecture held via the free video-conferencing software Zoom. You are encouraged to join the lecture live, but will have the opportunity to view the recorded session later if you are unable to attend at the scheduled time. Each lecture session will conclude with a hands-on exercise reviewing the content covered, to be completed on your own. An additional lab session will be held Tuesday and Thursday afternoons, where you can review the exercise results with the instructor and ask any questions. 0.2.1 Schedule 0.2.1.1 Day 1 * [Your First Shiny App](#first-app) * Overview of the UI/server structure * Inputs, outputs, and action buttons * Reactive functions * [ShinyDashboard](#shinydashboard) * Basic template for shinydashboard projects * Sidebar, menu navigation, and tabs * Row- and column-based layouts 0.2.1.2 Day 2 * [Different input types](#inputs) * [Different output types](#outputs) * [Reading and saving data](#data) * [Reactive functions](#reactives) 0.2.1.3 Day 3 * Customizing Your Apps * [CSS, HTML, and Javascript](#web) * [Structuring a complex app](#structure) * Intermediate Patterns * [Debugging and error handling](#debugging) * [Displaying elements contingent on the state of other elements](#contingency) 0.2.1.4 Day 4 * [Sharing Your Apps](#sharing) * shinyapps.io * Self-hosting a shiny server * GitHub * In an R package * Advanced Patterns * [Creating and downloading a customized report](#reports) * [Shiny modules for repeated structures](#modules) We understand that scheduling is difficult during this unpredictable time. If you prefer, you may take all or part of the course asynchronously. The video recordings will be made available within 24 hours of each session and will be accessible for two weeks after the seminar, meaning that you will get all of the class content and discussions even if you cannot participate synchronously. Closed captioning is available for all live and recorded sessions. 0.3 Computing To participate in the hands-on exercises, you are strongly encouraged to use a computer with the most recent version of R installed. Participants are also encouraged to download and install RStudio, a front-end for R that makes it easier to work with. This software is free and available for Windows, Mac, and Linux platforms. 0.4 Who Should Register? You need to have basic familiarity with R, including data import, data processing, visualization, and functions and control structures (e.g., if/else). Instruction will be done using RStudio. Some familiarity with ggplot2 and dplyr would be useful. You definitely do not need to be an expert coder, but the following code should not be challenging to understand. library(ggplot2) pets &lt;- read.csv(&quot;pets.csv&quot;) dv &lt;- sample(c(&quot;score&quot;, &quot;weight&quot;), 1) if (dv == &quot;score&quot;) { g &lt;- ggplot(pets, aes(pet, score, fill = country)) } else if (dv == &quot;weight&quot;) { g &lt;- ggplot(pets, aes(pet, weight, fill = country)) } r + geom_violin(alpha = 0.5) If you want to brush up on your R (especially tidyverse), and also gain familiarity with the instructor’s teaching style, the first seven chapters of Data Skills for Reproducible Science provide a good overview. 0.5 Further Resources There are a lot of great resources online to reinforce or continue your learning about Shiny. RStudio Shiny Tutorials 0.6 Glossary term definition data-wrangling The process of preparing data for visualisation and statistical analysis. function A named section of code that can be reused. rstudio An integrated development environment (IDE) that helps you process R code. shiny An R package that builds interactive web apps tidyverse A set of R packages that help you create and work with tidy data "],["first-app.html", "Chapter 1 Your First Shiny App 1.1 The Demo App 1.2 Overview of the UI/server structure 1.3 Inputs, outputs, and action buttons 1.4 Reactive functions 1.5 Glossary 1.6 Exercises", " Chapter 1 Your First Shiny App 1.1 The Demo App To start, let’s walk through the basics of setting up a shiny app, starting with the example built into RStudio I won’t explain yet how shiny apps are structured; the goal is to just get something up and running, and give you some familiarity with the layout of a fairly simple app. 1.1.1 Set Up the Demo App Figure 1.1: Creating a demo app. Under the File menu, choose New Project.... You will see a popup window like the one above. Choose New Directory. Choose Shiny Web Application as the project type. I like to put all of my apps in the same directory`, but it doesn’t matter where you save it. Your RStudio interface should look like this now. You don’t have to do anything else at this step. If RStudio has changed their demo app and your source code doesn’t look like this, replace it with the code below: View Code # # This is a Shiny web application. You can run the application by clicking # the &#39;Run App&#39; button above. # # Find out more about building applications with Shiny here: # # http://shiny.rstudio.com/ # library(shiny) # Define UI for application that draws a histogram ui &lt;- fluidPage( # Application title titlePanel(&quot;Old Faithful Geyser Data&quot;), # Sidebar with a slider input for number of bins sidebarLayout( sidebarPanel( sliderInput(&quot;bins&quot;, &quot;Number of bins:&quot;, min = 1, max = 50, value = 30) ), # Show a plot of the generated distribution mainPanel( plotOutput(&quot;distPlot&quot;) ) ) ) # Define server logic required to draw a histogram server &lt;- function(input, output) { output$distPlot &lt;- renderPlot({ # generate bins based on input$bins from ui.R x &lt;- faithful[, 2] bins &lt;- seq(min(x), max(x), length.out = input$bins + 1) # draw the histogram with the specified number of bins hist(x, breaks = bins, col = &#39;darkgray&#39;, border = &#39;white&#39;) }) } # Run the application shinyApp(ui = ui, server = server) Click on Run App in the top right corner of the source pane. The app will open up in a new window. Play with the slider and watch the histogram change. You can also open up the app in a web browser by clicking on Open in Browser. 1.1.2 Modify the Demo App Now we’re going to make a series of changes to the demo app until it’s all your own. You can close the app by closing the window or browser tab it’s running in, or leave it running while you edit the code. If you have multiple screens, it’s useful to have the app open on one screen and the code on another. Find the application title. It is the first argument to the function titlePanel. Change the title to \"My First App\". Make sure the title is inside quotes and the whole quoted string is inside the parentheses. Save the file (cmd-S or File &gt; Save). Click Run App (or Reload App if you haven’t closed the app window) in the source pane. If you haven’t saved your changes, it will prompt you to do so. Check that the app title has changed. Now let’s change the input. Find the function sliderInput (line 21). The first argument is the name you can use in the code to find the value of this input, so don’t change it just yet. The second argument is the text that displays before the slider. Change this to something else and re-run the app. sliderInput(&quot;bins&quot;, &quot;Number of bins:&quot;, min = 0, max = 50, value = 30) See if you can figure out what the next three arguments to sliderInput do. Change them to different integers, then re-run the app to see what’s changed. The arguments to the function sidebarPanel are just a list of things you want to display in the sidebar. To add some explanatory text in a paragraph before the sliderInput, just use the paragraph function p(\"My text\") sidebarPanel( p(&quot;I am explaining this perfectly&quot;), sliderInput(&quot;bins&quot;, &quot;Choose the best bin number:&quot;, min = 10, max = 40, value = 25) ) The sidebar shows up on the left if your window is wide enough, but moves to the top of the screen if it’s too narrow. I don’t like it there, so we can move this text out of the sidebar and to the top of the page, just under the title. Try this and re-run the app. # Application title titlePanel(&quot;My First App&quot;), p(&quot;I am explaining this perfectly&quot;), # Sidebar with a slider input for number of bins sidebarLayout(...) See where you can move the text in the layout of the page and where causes errors. I’m also not keen on the grey plot. We can change the plot colour inside the hist function. # draw the histogram with the specified number of bins hist(x, breaks = bins, col = &#39;steelblue3&#39;, border = &#39;grey30&#39;) There are a lot of ways to represent colour in R. The easiest three are: hexadecimal colours like #0066CC, the rgb or hsl functions, colour names (type colours() in the console) I like steelblue3, as it’s pretty close to the shiny interface default colour, but feel free to choose whatever you like. I prefer ggplot graphs, so let’s make the plot with geom_histogram instead of hist (which is a great function for really quick plots). Since we need several functions from the ggplot2 package, we’ll need to load that package at the top of the script, just under where the shiny package is loaded: library(shiny) library(ggplot2) You can replace all of the code in the renderPlot function with the code below. output$distPlot &lt;- renderPlot({ # create plot ggplot(faithful, aes(waiting)) + geom_histogram(bins = input$bins, fill = &quot;steelblue3&quot;, colour = &quot;grey30&quot;) + xlab(&quot;What are we even plotting here?&quot;) + theme_minimal() }) You can set the fill and colour to whatever colours you like, and change theme_minimal() to one of the other built-in ggplot themes. What are we even plotting here? Type ?faithful into the console pane to see what the waiting column represents (faithful is a built-in demo dataset). Change the label on the x-axis to something more sensible. 1.1.3 Add New Things The faithful dataset includes two columns:eruptions and waiting. We’ve been plotting the waiting variable, but what if you wanted to plot the eruptions variable instead? Try plotting the eruption time (eruptions) instead of the waiting time. You just have to change one word in the ggplot function and update the x-axis label. We can add another input widget to let the user switch between plotting eruption time and wait time. The RStudio Shiny tutorial has a great overview of the different input options. We need to toggle between two options, so we can use either radio buttons or a select box. Radio buttons are probably best if you have only a few options and the user will want to see them all at the same time to decide. Add the following code as the first argument to sidebarPanel(), which just takes a list of different widgets. radioButtons is the widget we’re using. The first argument is display_var, which we will use later in the code to find the value of this widget. The second argument is the label to display to the user. The next argument is choices, which is a list of choices in the format c(\"label1\" = \"value1\", \"label2 = \"value2\", ...). The label is what gets shown to the user and the value is what gets used by the code (these can be the same, but you often want the user label to be more descriptive). The last argument is selected, which is the value of the default choice. Save this and re-run the app. radioButtons(&quot;display_var&quot;, &quot;Which variable to display&quot;, choices = c(&quot;Waiting time to next eruption&quot; = &quot;waiting&quot;, &quot;Eruption time&quot; = &quot;eruptions&quot;), selected = &quot;waiting&quot; ), You should have a radio button interface now. You can click on the options to switch the button, but it won’t do anything to your plot yet. We need to edit the plot-generating code to make that happen. First, we need to change the x-axis label depending on what we’re graphing. We use an if/else statement to set the variable xlabel to one thing if input$display_var is equivalent to \"eruptions\", and to something else if it’s equivalent to \"waiting\". Put this code at the very beginning of the code block for the renderPlot function (after the line output$distPlot &lt;- renderPlot({). # set x-axis label depending on the value of display_var if (input$display_var == &quot;eruptions&quot;) { xlabel &lt;- &quot;Eruption Time (in minutes)&quot; } else if (input$display_var == &quot;waiting&quot;) { xlabel &lt;- &quot;Waiting Time to Next Eruption (in minutes)&quot; } The double-equal-signs == means \"equivalent to and is how you check if two things are the same; if you only use one equal sign, you set the variable on the left to the value on the right. Then we have to edit the ggplot function to use the new label and to plot the correct column. The variable input$display_var gives you the user-input value of the widget called display_var. # create plot ggplot(faithful, aes(.data[[input$display_var]])) + geom_histogram(bins = input$bins, fill = &quot;steelblue3&quot;, colour = &quot;grey30&quot;) + xlab(xlabel) + theme_minimal() Notice that the function aes(waiting) from before has changed to aes(.data[[input$display_var]]). Because input$display_var is a r glossary(“string”), we have to select it from the .data placeholder (which refers to the faithful data table) using double brackets. Re-run your app and see if you can change the data and x-axis label with your new widget. If not, check that your code against the code in shinyintro::newapp(\"first_demo\"). Figure 1.2: First Demo App 1.2 Overview of the UI/server structure Now that we’ve made and modified our first working app, it’s time to learn a bit about how a shiny app is structured. A shiny app is made of two main parts, a UI, which defines what the user interface looks like, and a server function, which defines how the interface behaves. The function shinyApp() puts the two together to run the application in a web browser. # Load libraries ---- library(shiny) # Define UI ---- ui &lt;- fluidPage() # Define server logic ---- server &lt;- function(input, output) { } # Run the application ---- shinyApp(ui = ui, server = server) Create a new app called “basic_demo” and replace all the text in app.R with the code above. You should be able to run the app and see just a blank page. 1.2.1 UI The UI is created by one of the ui-building “*Page” functions from the shiny or shinydashboard package, such as fluidPage(), fixedPage(), fillPage() or dashboardPage(). The ui-building functions set up the parts of the webpage, which are created by more shiny functions that you list inside of the page function, separated by commas. 1.2.1.1 Tags For example, the code below displays: a title panel with the text “Basic Demo” a level-two header with the text “My favourite things” an unordered list (tags$ul) containing several list items (tags$li) a paragraph with the text “This is a very basic demo.” an image of the shinyintro logo with a width and height of 100 pixels ui &lt;- fluidPage( titlePanel(&quot;Basic Demo&quot;), h2(&quot;My favourite things&quot;), tags$ul( tags$li(&quot;Coding&quot;), tags$li(&quot;Cycling&quot;), tags$li(&quot;Cooking&quot;) ), p(&quot;This is a very basic demo.&quot;), tags$img(src = &quot;https://debruine.github.io/shinyintro/images/shinyintro.png&quot;, width = &quot;100px&quot;, height = &quot;100px&quot;) ) Many of the functions used to create parts of the website are the same as HTML tags, which are ways to mark the beginning and end of different types of text. Most HTML tags are available in shiny by using the tags$tag-name() function, but some of the more common tags, like p() or h1()-h6()also have a version where you can omit thetags$` part. You can see a list of all of the tags available in Shiny at the tag glossary Add the code above to your basic_demo\" app and replace my favourite things with yours. Make the list an ordered list (instead of unordered) and change the image size. 1.2.1.2 Page Layout You usually want your apps to have a more complex layout than just each element stacked below the previous one. The code below wraps the elements after the title panel inside a flowLayout(). ui &lt;- fluidPage( titlePanel(&quot;Basic Demo&quot;), flowLayout( h2(&quot;My favourite things&quot;), tags$ul( tags$li(&quot;Coding&quot;), tags$li(&quot;Cycling&quot;), tags$li(&quot;Cooking&quot;) ), p(&quot;This is a very basic demo.&quot;), tags$img( src = &quot;https://debruine.github.io/shinyintro/images/shinyintro.png&quot;, width = &quot;100px&quot;, height = &quot;100px&quot; ) ) ) Replace the ui code in your basic_demo\" app with the code above and run it in a web browser. What happens when you change the width of the web browser? Change flowLayout to verticalLayout or splitLayout and see what changes. You can use a sidebarLayout() to arrange your elements into a sidebarPanel() and a mainPanel(). If the browser width is too narrow, the sidebar will display on top of the main panel. ui &lt;- fluidPage( titlePanel(&quot;Basic Demo&quot;), sidebarLayout( sidebarPanel( h2(&quot;My favourite things&quot;), tags$ul( tags$li(&quot;Coding&quot;), tags$li(&quot;Cycling&quot;), tags$li(&quot;Cooking&quot;) ) ), mainPanel( p(&quot;This is a very basic demo.&quot;), tags$img( src = &quot;https://debruine.github.io/shinyintro/images/shinyintro.png&quot;, width = &quot;100px&quot;, height = &quot;100px&quot; ) ) ) ) 1.3 Inputs, outputs, and action buttons So far, we’ve just put static elements into our UI. What makes Shiny apps work is dynamic elements like inputs, outputs, and action buttons. 1.3.1 Inputs Inputs are ways for the users of your app to communicate with the app. They are things like drop-down menus or checkboxes. We’ll go into the different types of inputs in the Inputs chapter. Below we’ll turn the list of favourite things into a checkbox list. checkboxGroupInput(inputId = &quot;fav_things&quot;, label = &quot;What are your favourite things?&quot;, choices = c(&quot;Coding&quot;, &quot;Cycling&quot;, &quot;Cooking&quot;) ) Most inputs are structured like this, with an inputId, which needs to be a unique string not used as the ID for any other input or output in your app, a label that contains the question, and a list of choices or other parameters that determine what type of values the input will record. 1.3.2 Outputs Outputs are placeholders for things that the server() function will create. There are different output functions for different types of outputs, like text, plots, and tables. We’ll go into the different types of outputs in detail in the Outputs chapter. Below, we’ll make a placeholder for some text that we’ll display after counting the number of favourite things. textOutput(outputId = &quot;n_fav_things&quot;) Most outputs are structured like this, with just a unique outputId. 1.3.3 Action buttons Action buttons are a special type of input that register button clicks. Below we’ll make an action button that users can click once they’ve selected all of their favourite things. actionButton(inputId = &quot;count_fav_things&quot;, label = &quot;Count&quot;, icon = icon(&quot;calculator&quot;) ) Action buttons require a unique inputId and a label for the button text. You can also add an icon. Choose a free icon from fontawesome. Put the input, output, and action button into the ui and run it. You can see that the input checkboxes are selectable and the button is clickable, but nothing is displayed in the text output. We need some code in the server() function to handle that. ui &lt;- fluidPage( titlePanel(&quot;Basic Demo&quot;), sidebarLayout( sidebarPanel( checkboxGroupInput(inputId = &quot;fav_things&quot;, label = &quot;What are your favourite things?&quot;, choices = c(&quot;Coding&quot;, &quot;Cycling&quot;, &quot;Cooking&quot;) ), actionButton(inputId = &quot;count_fav_things&quot;, label = &quot;Count&quot;, icon = icon(&quot;calculator&quot;) ) ), mainPanel( textOutput(outputId = &quot;n_fav_things&quot;) ) ) ) 1.4 Reactive functions Reactive functions are functions that run when their inputs change. Inside the server function, the object input is a named list of the values of all of the inputs. For example, if you want to know which items in the select input named “fav_things” were selected, you would use input$fav_things. Here, we just want to count how many items are checked. We want to do this whenever the button “count_fav_things” is clicked, so we can use the reactive function observeEvent() to do this. Every time the value of input$count_fav_things changes (which happens when it is clicked), it will run the code inside of the curly brackets {}. The code will only run when input$count_fav_things changes, not when any inputs inside the function change. server &lt;- function(input, output) { # count favourite things observeEvent(input$count_fav_things, { n &lt;- length(input$fav_things) count_text &lt;- sprintf(&quot;You have %d favourite things&quot;, n) }) } Now we want to display this text in the output “n_fav_things.” We need to use a render function that is paired with our output function. Since “n_fav_things” was made with textOutput(), we fill it with the renderText() function. server &lt;- function(input, output) { # count favourite things observeEvent(input$count_fav_things, { n &lt;- length(input$fav_things) count_text &lt;- sprintf(&quot;You have %d favourite things&quot;, n) output$n_fav_things &lt;- renderText(count_text) }) } As always in coding, there are many ways to accomplish the same thing. These methods have different pros and cons that we’ll learn more about in the Reactive chapter. Here is another pattern that does that same as above. This pattern uses the reactive() function to update the value of a new function called count_text() whenever any inputs inside the reactive function change. We use the isolate() function to prevent count_text() from changing when users click the checkboxes. Whenever the returned value of count_text() changes, this triggers an update of the “n_fav_things” output. server &lt;- function(input, output) { # update count_text on fav_things count_text &lt;- reactive({ input$count_fav_things # just here to trigger the reactive fav_things &lt;- isolate(input$fav_things) # don&#39;t trigger on checks n &lt;- length(fav_things) sprintf(&quot;You have %d favourite things&quot;, n) }) # display count_text when it updates output$n_fav_things &lt;- renderText(count_text()) } Compare the app behaviour with the first pattern versus the second. How are they different? What happens if you remove the isolate() function from around input$fav_things? 1.5 Glossary term definition argument A variable that provides input to a function. dynamic html-tags integer A data type representing whole numbers. list A container data type that allows items with different data types to be grouped together. object A word that identifies and stores the value of some data for later use. package A group of R functions. panes RStudio is arranged with four window “panes.” rstudio An integrated development environment (IDE) that helps you process R code. server This is the part of a Shiny app that works with logic. shiny An R package that builds interactive web apps static string A piece of text inside of quotes. ui The User Interface. This usually refers to a Shiny App as the user will see it. widget A interactive web element, like a dropdown menu or a slider. 1.6 Exercises 1.6.1 1. Addition App Create the following app. Use the numericInput() function to create the inputs. Figure 1.3: Add Demo App UI ui &lt;- fluidPage( titlePanel(&quot;Addition Demo&quot;), sidebarLayout( sidebarPanel( numericInput(&quot;n1&quot;, &quot;First number&quot;, 0), numericInput(&quot;n2&quot;, &quot;Second number&quot;, 0), actionButton(&quot;add&quot;, &quot;Add Numbers&quot;) ), mainPanel( textOutput(outputId = &quot;n1_plus_n2&quot;) ) ) ) Sever observeEvent pattern server &lt;- function(input, output) { # add numbers observeEvent(input$add, { sum &lt;- input$n1 + input$n2 add_text &lt;- sprintf(&quot;%d + %d = %d&quot;, input$n1, input$n2, sum) output$n1_plus_n2 &lt;- renderText(add_text) }) } Sever reactive pattern server &lt;- function(input, output) { add_text &lt;- reactive({ input$add # triggers reactive n1 &lt;- isolate(input$n1) n2 &lt;- isolate(input$n2) sprintf(&quot;%d + %d = %d&quot;, n1, n2, n1 + n2) }) output$n1_plus_n2 &lt;- renderText(add_text()) } "],["shinydashboard.html", "Chapter 2 ShinyDashboard 2.1 Basic template for shinydashboard projects 2.2 Sidebar, menu navigation, and tabs 2.3 Row- and column-based layouts 2.4 Glossary", " Chapter 2 ShinyDashboard 2.1 Basic template for shinydashboard projects 2.2 Sidebar, menu navigation, and tabs 2.3 Row- and column-based layouts 2.4 Glossary "],["inputs.html", "Chapter 3 Inputs 3.1 Input functions 3.2 Glossary", " Chapter 3 Inputs 3.1 Input functions Inputs are ways that users can communicate information to the Shiny app. Explore some different input types in the embedded app below before you read about how to set up each type. You can run this app locally with shinyintro::app(\"input_demo\") or view it in a separate tab with the [showcase interface](&lt;https://shiny.psy.gla.ac.uk/debruine/input_demo/({target=\"_blank\"}. Figure 3.1: Input Demo App 3.1.1 textInput textInput() creates a one-line box for short text input. demo_text &lt;- textInput(&quot;demo_text&quot;, label = &quot;Name&quot;, value = &quot;&quot;, width = &quot;100%&quot;, placeholder = &quot;Your Name&quot;) 3.1.2 textAreaInput textAreaInput() creates a multi-line box for longer text input. demo_textarea &lt;- textAreaInput(&quot;demo_textarea&quot;, label = &quot;Biography&quot;, value = &quot;&quot;, width = &quot;100%&quot;, rows = 5, placeholder = &quot;Tell us something interesting about you.&quot;) 3.1.3 selectInput sekectInput() creates a drop-down menu. Set the first choice to \"\" to default to NA. If your choices are a named list, the names are what is shown and the values are what is recorded. If the choices aren’t named, the displayed and recorded values are the same. demo_select &lt;- selectInput(&quot;demo_select&quot;, label = &quot;Do you like Shiny?&quot;, choices = list(&quot;&quot;, &quot;Yes, I do&quot; = &quot;y&quot;, &quot;No, I don&#39;t&quot; = &quot;n&quot;), selected = NULL, width = &quot;100%&quot;) You can also make a select where users can choose multiple options. genders &lt;- list( # no blank needed &quot;Non-binary&quot; = &quot;nb&quot;, &quot;Male&quot; = &quot;m&quot;, &quot;Female&quot; = &quot;f&quot;, &quot;Agender&quot; = &quot;a&quot;, &quot;Gender Fluid&quot; = &quot;gf&quot; ) demo_select_multi &lt;- selectInput(&quot;demo_select2&quot;, label = &quot;Gender (select all that apply)&quot;, choices = genders, selected = NULL, multiple = TRUE, selectize = FALSE, size = 5) 3.1.4 checkboxGroupInput However, this interface almost always looks better with a checkbox group. demo_cbgi &lt;- checkboxGroupInput(&quot;demo_cbgi&quot;, label = &quot;Gender (select all that apply)&quot;, choices = genders) 3.1.5 checkboxInput You can also make a single checkbox. The value is TRUE when checked and FALSE when not. demo_cb &lt;- checkboxInput(&quot;demo_cb&quot;, label = &quot;I love R&quot;, value = TRUE) Sliders allow you to choose numbers between a minimum and maximum. demo_slider &lt;- sliderInput(&quot;demo_slider&quot;, label = &quot;Age&quot;, min = 0, max = 100, value = 0, step = 1, width = &quot;100%&quot;) 3.1.6 Setting inputs programatically Sometimes you need to change the value of an input with code, such as when resetting a questionnaire or in response to an answer on another item. The following code reseats all of the inputs above. updateTextInput(session, &quot;demo_text&quot;, value = &quot;&quot;) updateTextAreaInput(session, &quot;demo_textarea&quot;, value = &quot;&quot;) updateSelectInput(session, &quot;demo_select&quot;, selected = &quot;&quot;) updateCheckboxGroupInput(session, &quot;demo_cbgi&quot;, selected = character(0)) updateCheckboxInput(session, &quot;demo_cb&quot;, value = TRUE) updateSliderInput(session, &quot;demo_slider&quot;, value = 0) Note that select inputs and checkbox groups use the argument selected and not value. If you want to set all the values in a checkbox group to unchecked, set selected = character(0). 3.2 Glossary "],["outputa.html", "Chapter 4 Outputs 4.1 Glossary", " Chapter 4 Outputs Output are ways that the Shiny app can dynamically display information to the user. In the user interface (UI), you create outputs with IDs that you reference in and associated rendering function inside the server function. Explore some different output types in the embedded app below before you read about how to set up each type. You can run this app locally with shinyintro::app(\"output_demo\") or view it in a separate tab with the [showcase interface](&lt;https://shiny.psy.gla.ac.uk/debruine/output_demo/({target=\"_blank\"}. Figure 4.1: Output Demo App 4.0.1 textOutput The function textOutput() defaults to text inside a &lt;span&gt; or &lt;div&gt; element, but you can use a different element with the container argument. # in the UI textOutput(&quot;demo_text&quot;, container = tags$h3) # in the server function output$demo_text &lt;- renderText({ sprintf(&quot;Plot of %s&quot;, input$y) }) If you use verbatimTextOutput() in the UI (no change to the server function), it will show the output in a fixed-width font. This can be good for code or text you want the user to copy. # in the UI verbatimTextOutput(&quot;demo_verbatim&quot;) # in the server function output$demo_verbatim &lt;- renderText({ code &lt;- &quot;ggplot(iris, aes(x = Species, y = %s, color = Species)) + geom_violin(show.legend = FALSE) + stat_summary(show.legend = FALSE)&quot; sprintf(code, input$y) }) 4.0.2 uiOutput If you want to dynamically create parts of the user interface (UI), you can use uiOutput(). You can create the user interface using the input functions # in the UI uiOutput(&quot;demo_ui&quot;) # in the server function output$demo_ui &lt;- renderUI({ cols &lt;- names(iris)[1:4] selectInput(&quot;y&quot;, &quot;Column to plot&quot;, cols, &quot;Sepal.Length&quot;) }) The function htmlOutput() is exactly the same as uiOutput(), so you might see that in some code examples, but I use uiOutput() to make the connection with renderUI() clearer, since there is no renderHTML(). 4.0.3 plotOutput # in the UI plotOutput(&quot;demo_plot&quot;) # in the server function output$demo_plot &lt;- renderPlot({ ggplot(iris, aes(x = Species, y = .data[[input$y]], color = Species)) + geom_violin(show.legend = FALSE) + stat_summary(show.legend = FALSE) + ylab(input$y) }) If you want to create dynamic plots that change with input, note how you need to use y = .data[[input$y]] inside the aes() function, instead of just y = input$y. 4.0.4 imageOutput # in the UI imageOutput(&quot;demo_image&quot;) # in the server function output$demo_image &lt;- renderImage({ list(src = &quot;images/flower.jpg&quot;, width = 100, height = 100, alt = &quot;A flower&quot;) }, deleteFile = FALSE) You can dynamically display images of any type, but one of the most useful ways to use image outputs is to control the aspect ratio and relative size of plots. When you save a temporary file, you should set deleteFile = TRUE in the renderImage() function (this stops unneeded plots using memory). # in the UI imageOutput(&quot;demo_image&quot;) # in the server function output$demo_image &lt;- renderImage({ # make the plot g &lt;- ggplot(iris, aes(x = Species, y = .data[[input$y]], color = Species)) + geom_violin(show.legend = FALSE) + stat_summary(show.legend = FALSE) + ylab(input$y) # save to a temporary file plot_file &lt;- tempfile(fileext = &quot;.png&quot;) ggsave(plot_file, demo_plot(), units = &quot;in&quot;, dpi = 72, width = 7, height = 5) # Return a list containing the filename list(src = plot_file, width = &quot;100%&quot;, # don&#39;t set the height to keep aspect ratio alt = &quot;The plot&quot;) }, deleteFile = TRUE) 4.0.5 tableOutput The reanderTable() function will display a table from any data frame it returns. # in the UI tableOutput(&quot;demo_table&quot;) # in the server function output$demo_table &lt;- renderTable({ iris %&gt;% group_by(Species) %&gt;% summarise(mean = mean(.data[[input$y]]), sd = sd(.data[[input$y]])) }) Note how you need to use .data[[input$y]] inside the dplyr::summarise() function, instead of just input$y to dynamically choose which variable to summarise. 4.0.6 dataTableOutput If you have a long table to show, or one that you want users to be able to sort or search, use dataTableOutput(). You can customise data tables in many ways, but we’ll stick with a basic example here. # in the UI DT::dataTableOutput(&quot;demo_datatable&quot;) # in the server function output$demo_datatable &lt;- DT::renderDataTable({ iris }, options = list(pageLength = 10)) The basic shiny package has dataTableOutput() and renderDataTable() functions, but they can be buggy. The version in the DT package are better and have some additional functions, so I use those. 4.1 Glossary "],["data.html", "Chapter 5 Reading and saving data 5.1 Local Data 5.2 Google Sheets 5.3 Glossary", " Chapter 5 Reading and saving data 5.1 Local Data You can read and write data from a Shiny app the same way you do from any R script. We will focus on reading data, since writing data locally can cause problems and is better done with Google Sheets. The base directory for a Shiny app is the directory that app.R is in. I recommend keeping your data in a directory called “data” to keep things tidy. # read local data my_data &lt;- readxl::read_xls(&quot;data/my_data.xls&quot;) # read data on the web countries &lt;- readr::read_csv(&quot;https://datahub.io/core/country-list/r/data.csv&quot;) languages &lt;- jsonlite::read_json(&quot;https://datahub.io/core/language-codes/r/language-codes.json&quot;) 5.2 Google Sheets One of the best ways to start collecting data with a Shiny app is with Google Sheets. This allows you to collect data to the same place from multiple servers, which might happen if you’re running the app locally on more than one computer or through a service like shinyapps.io. The R package googlesheets4 makes it easy to work with Google Sheets from R. If you just want to read data from a public Google Sheet, you don’t need any authorisation. Just start your code with gs4_deauth() after you load the googlesheets4 library (otherwise you’ll be prompted to log in). Then you can read data like this: library(googlesheets4) gs4_deauth() sheet_id &lt;- &quot;https://docs.google.com/spreadsheets/d/1tQCYQrI4xITlPyxb9dQ-JpMDYeADovIeiZZRNHkctGA/&quot; read_sheet(sheet_id) number letter 1 A 2 B 3 C However, even if a Google Sheet is publicly editable, you can’t add data to it without authorising your account. data &lt;- data.frame(number = 4, letter = &quot;D&quot;) sheet_append(sheet_id, data) ## Error: Client error: (401) UNAUTHENTICATED ## * Request not authenticated due to missing, invalid, or expired OAuth token. ## * Request is missing required authentication credential. Expected OAuth 2 access token, login cookie or other valid authentication credential. See https://developers.google.com/identity/sign-in/web/devconsole-project. You can authorise interactively using the following code (and your own email), which will prompt you to authorise “Tidyverse API Packages” the first time you do this. gs4_auth(email = &quot;debruine@gmail.com&quot;) However, this won’t work if you want your Shiny apps to be able to access your Google Sheets. 5.2.1 Authorisation for Apps First, you need to get a token and store it in a cache folder in your app directory. We’re going to call that directory “.secrets.” Run the following code in your console (NOT in an Rmd file). This will open up a web browser window and prompt you to choose your Google account and authorise “Tidyverse API Packages.” setwd(app_directory) gs4_auth(email = &quot;debruine@gmail.com&quot;, cache = &quot;.secrets&quot;) # optionally, authorise google drive to search your drive # googledrive::drive_auth(email = &quot;debruine@gmail.com&quot;, cache = &quot;.secrets&quot;) Figure 5.1: Prompts to choose an account, grant permissions, and confirm. When you have finished, you will see a page that says something like, “Authentication complete. Please close this page and return to R.” In the file pane in RStudio, you should now see a directory. called “.secrets” in the app directory. If you are using GitHub, you don’t want to save your secret info to a public repository, so run the following code to ignore any directories called “.secrets” (so they will only exist on your computer and not on GitHub). usethis::use_git_ignore(&quot;.secrets&quot;) usethis::use_git_ignore(&quot;*/.secrets&quot;) Now, you can include the following code at the top of your app.R script to authorise the app to read from and write to your files. gs4_auth(cache = &quot;.secrets&quot;, email = &quot;debruine@gmail.com&quot;) 5.2.2 Accessing an existing sheet If you have an existing Google Sheet, you can access it by URL. sheet_id &lt;- &quot;https://docs.google.com/spreadsheets/d/1tQCYQrI4xITlPyxb9dQ-JpMDYeADovIeiZZRNHkctGA/&quot; data &lt;- data.frame(number = 4, letter = &quot;D&quot;) sheet_append(sheet_id, data) read_sheet(sheet_id) number letter 1 A 2 B 3 C 4 D 5.2.3 Make a new sheet You can set up a new Google Sheet with code. You only need to do this once for a sheet that you will use with a Shiny app, and you will need to save the sheet ID. If you don’t specify the tab name(s), the sheet will be created with one tab called “Sheet1.” I recommend making only one sheet per app and saving each table in a separate tab. id &lt;- gs4_create(&quot;demo2&quot;, sheets = c(&quot;demographics&quot;, &quot;questionnaire&quot;)) id ## Spreadsheet name: demo2 ## ID: 1E54Z6heGXSUxg0CHM9U9bZ1dDc7nV3U_tHwVR813qJU ## Locale: en_US ## Time zone: Europe/London ## # of sheets: 2 ## ## (Sheet name): (Nominal extent in rows x columns) ## demographics: 1000 x 26 ## questionnaire: 1000 x 26 Include the ID at the top of your app like this: SHEET_ID 5.2.4 Add data You can add an empty data structure to your sheet by specifying the data types of each column like this: data &lt;- data.frame( name = character(0), birthyear = integer(0), parent = logical(0), score = double(0) ) write_sheet(data, SHEET_ID, &quot;demographics&quot;) read_sheet(SHEET_ID, &quot;demographics&quot;) %&gt;% names() ## [1] &quot;name&quot; &quot;birthyear&quot; &quot;parent&quot; &quot;score&quot; Or you can populate the table with starting data. data &lt;- data.frame( name = &quot;Lisa&quot;, birthyear = 1976L, R_user = TRUE, score = 10.2 ) write_sheet(data, SHEET_ID, &quot;demographics&quot;) read_sheet(SHEET_ID, &quot;demographics&quot;) name birthyear R_user score Lisa 1976 TRUE 10.2 Notice that birthyear is a double, not an integer. Google Sheets only have one numeric type, so both doubles and integers are coerced to doubles. 5.2.5 Appending data Then you can append new rows of data to the sheet. data &lt;- data.frame( name = &quot;Robbie&quot;, birthyear = 2007, R_user = FALSE, score = 12.1 ) sheet_append(SHEET_ID, data, &quot;demographics&quot;) read_sheet(SHEET_ID, &quot;demographics&quot;) name birthyear R_user score Lisa 1976 TRUE 10.2 Robbie 2007 FALSE 12.1 If you try to append data of a different type, some weird things can happen. Logical values added to a numeric column are cast as 0 (FALSE) and 1 (TRUE), while numeric values added to a logical column change the column to numeric. If you mix character and numeric values in a column, the resulting column is a column of one-item lists so that each list can have the appropriate data type. (Data frames in R cannot mix data types in the same column.) data &lt;- data.frame( name = 1, birthyear = FALSE, R_user = 0, score = &quot;No&quot; ) sheet_append(SHEET_ID, data, &quot;demographics&quot;) read_sheet(SHEET_ID, &quot;demographics&quot;) name birthyear R_user score Lisa 1976 1 10.2 Robbie 2007 0 12.1 1 0 0 No You must append data that has the same number and order of columns as the Google Sheet. If you send columns out of order, they will be recorded in the order you sent them, not in the order of the column names. If you send extra columns, the append will fail. The Shiny template we’re working with has a safer version of sheet_append() that you can access by uncommenting the line: # source(\"R/sheet_append.R\") This version gracefully handles data with new columns, missing columns, columns in a different order, and columns with a different data type. However, it reads the whole data sheet before deciding whether to append or overwrite the data, which can slow down your app, so is best used only during development when you’re changing things a lot. Once you have the final structure of your data, it’s better to use the original googlesheets4::sheet_append() function. 5.3 Glossary "],["reactives.html", "Chapter 6 Reactive functions 6.1 Glossary", " Chapter 6 Reactive functions 6.1 Glossary "],["web.html", "Chapter 7 CSS, HTML, and Javascript 7.1 Glossary", " Chapter 7 CSS, HTML, and Javascript 7.1 Glossary "],["structure.html", "Chapter 8 Structuring a complex app 8.1 Glossary", " Chapter 8 Structuring a complex app 8.1 Glossary "],["debugging.html", "Chapter 9 Debugging and error handling 9.1 RStudio Console Messages 9.2 JavaScript Console 9.3 Showcase Mode 9.4 tryCatch 9.5 Glossary", " Chapter 9 Debugging and error handling Bugs are a part of coding. A great coder isn’t someone who writes bug-free code on the first try (this is an unachievable goal), but rather someone who knows how to efficiently catch bugs. This sections presents a few simple ways to debug your Shiny app. See the article Debugging Shiny applications for further debugging strategies, including breakpoints and reactlog. 9.1 RStudio Console Messages Sending messages to the console is a simple way to debug your code. I like to keep track of what functions are being called by starting every function inside the server function with a message. The template includes a custom message logging function that helps you use this with both development and deployed apps: debug_msg(). For example, the code below prints “questionnaire submitted” every time the action button q_submit is pressed. It prints to the RStudio console when you’re developing and to the javascript console for deployed apps. observeEvent(input$q_submit, { debug_msg(&quot;questionnaire submitted&quot;) # rest of code ... }) 9.2 JavaScript Console I use FireFox Developer Edition when I’m developing web apps, but Chrome also has developer tools. In FireFox, go to Tools &gt; Browser Tools &gt; Web Developer Tools (opt-cmd-I). In Chrome, go to View &gt; Developer &gt; Developer Tools (opt-cmd-I). You can dock the tools to the bottom, right , or left of the window, or as a separate window. Figure 9.1: Javascript consoles in FireFox Developer Edition and Chrome. Shiny puts a lot of info you won’t care about into the logs, so our debug_msg() function writes messages to the debug console. You can filter just those messages by choosing only “Debug” in FireFox or “Verbose” in Chrome. 9.3 Showcase Mode You can view an app in showcase mode by setting “DisplayMode” to “Showcase” (instead of “Normal”) in the DESCRIPTION file in the app directory. When you’re in this mode, you can see your app code, css files, and javascript files. The functions in your server function will highlight in yellow each time they are run. However, this isn’t much help if many of your functions are in external files or you are using modules. Also, if your script is very long, you won’t be able to see the highlighting unless you’ve scrolled to the right section, so I find it more straightforward to use the message method described above. Title: Questionnaire Template Author: Lisa DeBruine License: CC-BY-4.0 DisplayMode: Showcase Type: Shiny Figure 9.2: Showcase mode. 9.4 tryCatch You’ve probably experienced the greyed out screen of a crashed app more than enough now. In development, the next step is to look at the console to see if you have a warning or error message. If you’re lucky, you can figure out where in the code this is happening (this is easier if you start all your functions with a debug message). 9.5 Glossary term definition console The pane in RStudio where you can type in commands and view output messages. "],["contingency.html", "Chapter 10 Contingent Display 10.1 Glossary", " Chapter 10 Contingent Display 10.1 Glossary "],["sharing.html", "Chapter 11 Sharing your Apps 11.1 shinyapps.io 11.2 Self-hosting a shiny server 11.3 GitHub 11.4 In an R package 11.5 Glossary 11.6 Exercises", " Chapter 11 Sharing your Apps 11.1 shinyapps.io Open Tools &gt; Global Options ... Go to the Publishing tab Click the Connect button and choose ShinyApps.io Click on the link to go to your account Click the Sign Up button and Sign up with GitHub You should now be in your shinyapps.io dashboard; click on your name in the upper right and choose Tokens Add a token Click Show next to the token and copy the text to the clipboard Go back to RStudio and paste the text in the box and click Connect Account Make sure the box next to “Enable publishing…” is ticked, click Apply, and close the options window ˙ You can test this by creating a simple app. If you have the shinyintro package, use the code below. shinyintro::newapp(&quot;mytestapp&quot;, &quot;input_demo&quot;) Open the app.R file and go to File &gt; Publish... in the menu (or click on the blue icon in the upper right corner of the source pane). Make sure these are the right files for your app, edit the title if you want, and click Publish. A web browser window will open after a few seconds showing your app online! You can now share it with your friends and colleagues. If publishing fails, check the Console pane. If you already have too many apps on shinyapps.io, you’ll see the message, “You have reached the maximum number of applications allowed for your account.” You can archive some of your apps from the shinyapps.io dashboard if this is the problem. 11.2 Self-hosting a shiny server Setting up a shiny server is beyond the scope of this class, but if you have access to one, you can ask the administrator how to access the correct directories and upload your app directories there. This solution is good if you want to save data locally and do not want to use Google Sheets. You can’t save data locally on shinyapps.io. If you save data locally on a shiny server, you may need to change the owner or permissions of the directory you save data in so that the web user can write to it. Ask the administrator of the server for help if this doesn’t make any sense to you. 11.3 GitHub GitHub is a great place to organise and share your code using version control. You can also use it to host Shiny app code for others to download and run on their own computer with RStudio. See Appendix B for instructions on how to set up git and a GitHub account. 11.4 In an R package 11.5 Glossary 11.6 Exercises 11.6.1 1. Shinyapps.io Upload another demo app to shinyapps.io. Check that you can access it online. Archive the app in the shinyapps.io dashboard. "],["reports.html", "Chapter 12 Customized reports 12.1 Glossary", " Chapter 12 Customized reports 12.1 Glossary "],["modules.html", "Chapter 13 Shiny modules for repeated structures 13.1 Modularizing the UI 13.2 Modularizing server functions 13.3 Glossary 13.4 Exercises", " Chapter 13 Shiny modules for repeated structures If you find yourself making nearly identical UIs or functions over and over in the same app, you might benefit from modules. This is a way to You can run this app locally with shinyintro::app(\"modules_demo\") or view it in a separate tab with the [showcase interface](&lt;https://shiny.psy.gla.ac.uk/debruine/modules_demo/({target=\"_blank\"}. Figure 13.1: Modules Demo App 13.1 Modularizing the UI The two tabPanels below follow nearly identical patterns. You can often identify a place where modules might be useful when you use a naming convention like {base}_{type} for the ids. iris_tab &lt;- tabPanel( &quot;iris&quot;, selectInput(&quot;iris_dv&quot;, &quot;DV&quot;, choices = names(iris)[1:4]), plotOutput(&quot;iris_plot&quot;), DT::dataTableOutput(&quot;iris_table&quot;) ) mtcars_tab &lt;- tabPanel( &quot;mtcars&quot;, selectInput(&quot;mtcars_dv&quot;, &quot;DV&quot;, choices = c(&quot;mpg&quot;, &quot;disp&quot;, &quot;hp&quot;, &quot;drat&quot;)), plotOutput(&quot;mtcars_plot&quot;), DT::dataTableOutput(&quot;mtcars_table&quot;) ) The first step in modularising your code is to make a function that creates the UIs above from the base ID and any other changing aspects. In the example above, the choices are different for each selectInput, so we’ll make a function that has the arguments id and choices. The first line of a UI module function is always ns &lt;- NS(id), which creates a shorthand way to add the base id to the id type. So instead of the selectInput’s name being “iris_dv” or “mtcars_dv,” we set it as ns(\"dv\"). All ids need to use this ns() function. tabPanelUI &lt;- function(id, choices) { ns &lt;- NS(id) tabPanel( id, selectInput(ns(&quot;dv&quot;), &quot;DV&quot;, choices = choices), plotOutput(ns(&quot;plot&quot;)), DT::dataTableOutput(ns(&quot;table&quot;)) ) } Now, you can replace two tabPanel definitions with just the following code. iris_tab &lt;- tabPanelUI(&quot;iris&quot;, names(iris)[1:4]) mtcars_tab &lt;- tabPanelUI(&quot;mtcars&quot;, c(&quot;mpg&quot;, &quot;disp&quot;, &quot;hp&quot;, &quot;drat&quot;)) 13.2 Modularizing server functions In our original code, we have four functions that create the two output tables and two output plots, but these are also largely redundant. output$iris_table &lt;- DT::renderDataTable({ iris }) output$iris_plot &lt;- renderPlot({ ggplot(iris, aes(x = Species, y = .data[[input$iris_dv]], fill = Species)) + geom_violin(alpha = 0.5, show.legend = FALSE) + scale_fill_viridis_d() }) output$mtcars_table &lt;- DT::renderDataTable({ mtcars }) output$mtcars_plot &lt;- renderPlot({ # handle non-string grouping mtcars$vs &lt;- factor(mtcars$vs) ggplot(mtcars, aes(x = vs, y = .data[[input$mtcars_dv]], fill = vs)) + geom_violin(alpha = 0.5, show.legend = FALSE) + scale_fill_viridis_d() }) The second step to modularising code is creating a server function. You can put all the functions the relate to the inputs and outputs in the UI function here, so we will include one to make the output table and one to make the output plot. The server function takes the base id as the first argument, and then any arguments you need to specify things that change between base implementations. Above, the tables show different data and the plots use different groupings for the x axis and fill, so we’ll add arguments for data and group_by. A server function always contains a moduleServer() function set up like below. tabPanelServer &lt;- function(id, data, group_by) { moduleServer(id, function(input, output, session) { # code ... }) } No you can copy in one set of server functions above, remove the base name (e.g., “iris_” or “mtcars_”) from and inputs or outputs, and replace specific instances of the data or grouping columns with data and group_by. tabPanelServer &lt;- function(id, data, group_by) { moduleServer(id, function(input, output, session) { output$table &lt;- DT::renderDataTable({ data }) output$plot &lt;- renderPlot({ # handle non-string groupings data[[group_by]] &lt;- factor(data[[group_by]]) ggplot(data, aes(x = .data[[group_by]], y = .data[[input$dv]], fill = .data[[group_by]])) + geom_violin(alpha = 0.5, show.legend = FALSE) + scale_fill_viridis_d() }) }) } In the original code, the grouping variables were unquoted, but it’s tricky to pass unquoted variable names to custom functions, and we already know how to refer to columns by a character object using .data[[char_obj]]. The grouping column Species in iris is already a factor, but recasting it as a factor won’t hurt, and is required for the mtcars grouping column vs. Now, you can replace the four functions inside the server function with these two lines of code. tabPanelServer(&quot;iris&quot;, data = iris, group_by = &quot;Species&quot;) tabPanelServer(&quot;mtcars&quot;, data = mtcars, group_by = &quot;vs&quot;) Our example only reduced our code by 4 lines, but it can save a lot of time, effort, and debugging on projects with many similar modules. For example, if you want to change the plots in your app to use a different geom, now you only have to change one function instead of two. 13.3 Glossary 13.4 Exercises 13.4.1 1. Repeat Example Try to implement the code above on your own. Create a copy of the “no_modules_demo” shinyintro::newapp(\"my_no_modules\", \"no_modules_demo\") Run the app and see how it works Create the UI module function and use it to replace iris_tab and mtcars_tab Create the server function and use it to replace the server functions 13.4.2 2. New Instance Add a new tab called “diamonds” that visualises the diamonds dataset. Choose the columns you want as choices in the selectInput() and the grouping column. UI Solution You can choose any of the numeric columns for the choices. diamonds_tab &lt;- tabPanelUI(&quot;diamonds&quot;, c(&quot;carat&quot;, &quot;depth&quot;, &quot;table&quot;, &quot;price&quot;)) Server Solution You can group by any of the categorical columns: cut, color, or clarity. tabPanelServer(&quot;diamonds&quot;, data = diamonds, group_by = &quot;cut&quot;) 13.4.3 3. Altering modules Add another selectInput() to the UI that allows the user to select the grouping variable. (iris only has one possibility, but mtcars and diamonds should have several) UI Solution You need to add a new selectInput() to the tabPanel. Remember to use the ns() function for the id. The choices for this select will also differ by data set, so you need to add group_choices to the arguments of this function. tabPanelUI &lt;- function(id, choices, group_choices) { ns &lt;- NS(id) tabPanel( id, selectInput(ns(&quot;dv&quot;), &quot;DV&quot;, choices = choices), selectInput(ns(&quot;group_by&quot;), &quot;Group By&quot;, choices = group_choices), plotOutput(ns(&quot;plot&quot;)), DT::dataTableOutput(ns(&quot;table&quot;)) ) } Update the plot function to use the value of this new input instead of “Species,” “vs,” and whatever you chose for diamonds. Server Solution You no longer need group_by in the arguments for this function because you are getting that info from an input. Instead of changing group_by to input$group_by in three places in the code below, I just added the line group_by &lt;- input$group_by at the top of the moduleServer() function. tabPanelServer &lt;- function(id, data) { moduleServer(id, function(input, output, session) { group_by &lt;- input$group_by # rest of the code is the same ... }) } 13.4.4 4. New module There is a fluidRow() before the tabsetPanel() in the ui that contains three infoBoxOutput() and three renderInfoBoxOutput() functions in the server function. Modularise the info boxes and their associated server functions. UI Function infoBoxUI &lt;- function(id, width = 4) { ns &lt;- NS(id) infoBoxOutput(ns(&quot;box&quot;), width) } Server Function infoBoxServer &lt;- function(id, title, fmt, icon, color = &quot;purple&quot;) { moduleServer(id, function(input, output, session) { output$box &lt;- renderInfoBox({ infoBox(title = title, value = format(Sys.Date(), fmt), icon = icon(icon), color = color) }) }) } UI Code In the ui, replace the fluidRow() with this: fluidRow( infoBoxUI(&quot;day&quot;), infoBoxUI(&quot;month&quot;), infoBoxUI(&quot;year&quot;) ) Server Code In the server() function, replace the renderInfoBox() functions with this: infoBoxServer(&quot;year&quot;, &quot;Year&quot;, &quot;%Y&quot;, &quot;calendar&quot;) infoBoxServer(&quot;month&quot;, &quot;Month&quot;, &quot;%m&quot;, &quot;calendar-alt&quot;) infoBoxServer(&quot;day&quot;, &quot;Day&quot;, &quot;%d&quot;, &quot;calendar-day&quot;)) "],["installing-r.html", "A Installing R A.1 Installing Base R A.2 Installing RStudio A.3 Installing LaTeX", " A Installing R Installing R and RStudio is usually straightforward. The sections below explain how and there is a helpful YouTube video here. A.1 Installing Base R Install base R from https://cran.rstudio.com/. Choose the download link for your operating system (Linux, Mac OS X, or Windows). If you have a Mac, install the latest release from the newest R-x.x.x.pkg link (or a legacy version if you have an older operating system). After you install R, you should also install XQuartz to be able to use some visualisation packages. If you are installing the Windows version, choose the “base” subdirectory and click on the download link at the top of the page. After you install R, you should also install RTools; use the “recommended” version highlighted near the top of the list. If you are using Linux, choose your specific operating system and follow the installation instructions. A.2 Installing RStudio Go to rstudio.com and download the RStudio Desktop (Open Source License) version for your operating system under the list titled Installers for Supported Platforms. A.3 Installing LaTeX You can install the LaTeX typesetting system to produce PDF reports from RStudio. Without this additional installation, you will be able to produce reports in HTML but not PDF. To generate PDF reports, you will additionally need: pandoc, and LaTeX, a typesetting language, available for WINDOWS: MikTeX Mac OS: MacTex (3.2GB download) or BasicTeX (78MB download, but should work fine) Linux: TeX Live "],["setup-git.html", "B Git and GitHub B.1 Get a GitHub account B.2 Set up RStudio B.3 Set your GitHub info B.4 Create an SSH Key on RStudio B.5 Create an SSH Key on GitHub", " B Git and GitHub There are many reasons to use version control. Git is one option and it is well-integrated into RStudio. GitHub is a free service to store your version controlled projects in the cloud and (optionally) share them with others. B.1 Get a GitHub account Go to GitHub and create a new account. Make sure your username is professional Use an email address that you won’t lose access to (e.g., gmail) B.2 Set up RStudio If you are a UofG INP staff/student, you can access the Glasgow Psychology RStudio site and skip to Set your GitHub info. If you are working from your own computer, follow the next 2 sub-steps: B.2.1 Install git You can check if git is already installed on your computer by going to Shell... under the Tools menu (or just open a terminal window) and typing which git. If you get an answer like /usr/local/bin/git then git is already installed. If not, install git and then use which git to check where it is installed. B.2.2 Enable version control in RStudio Go to Global Options... from the Tools menu and set the location of your git executable to the location from the previous step. Figure B.1: Set the location of git B.3 Set your GitHub info Run usethis::edit_git_config() in the console pane; it will open a file called .gitconfig. Replace GITHUB_EMAIL with the email address you used for github and GITHUB_USERNAME with your github username. [user] email = GITHUB_EMAIL name = GITHUB_USERNAME You can skip the rest of the steps if you are using your own computer because you can use https to access github. If you are using an RStudio server or just want to use SSH, follow the steps below. B.4 Create an SSH Key on RStudio Go to Global Options... from the Tools menu Click Create RSA Key... and enter a passphrase Figure B.2: Global options Click on View public key and copy the contents of the box B.5 Create an SSH Key on GitHub Go to GitHub &gt; Settings &gt; SSH and GPG keys Click New SSH Key Put RStudio server as the title (or My Computer Name if on your own computer) Paste your public key into the Key box Click Add SSH key Figure B.3: Add SSH key "],["symbols.html", "C Symbols", " C Symbols Symbol Book Term Also Known As () (round) brackets parentheses [] square brackets brackets {} curly brackets squiggly brackets &lt;&gt; chevrons angled brackets / guillemets &lt; less than &gt; greater than &amp; ampersand “and” symbol # hash pound / octothorpe / slash forward slash \\ backslash - dash hyphen / minus _ underscore * asterisk star ^ caret power symbol ~ tilde twiddle / squiggle = equal sign == double equal sign . full stop period / point ! exclamation mark bang / not ? question mark ’ single quote quote / apostrophe \" double quote quote %&gt;% pipe magrittr pipe | vertical bar pipe , comma ; semi-colon : colon @ “at” symbol various hilarious regional terms "]]

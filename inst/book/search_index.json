[["index.html", "Building Web Apps with R Shiny Overview 0.1 Example Apps 0.2 Code Horizons Course (27-30 July 2021) 0.3 Computing 0.4 Who Should Register? 0.5 Glossary", " Building Web Apps with R Shiny Lisa DeBruine 2021-07-05 Overview Shiny apps let you make web applications that do anything you can code in R. For example, you can share your data analysis in a dynamic way with people who don’t use R, collect and visualize data, or even make data aRt. While there is a wealth of material available on the internet to help you get started with Shiny, it can be difficult to see how everything fits together. This class will take a predominantly live coding approach, rather than a lecture-only approach, so you can code along with the instructor and deal with the inevitable bugs and roadblocks together. This class will teach you the basics of Shiny app programming, giving you skills that will form the basis of almost any app you want to build. By the end of the class, you will have created a custom app that collects and saves data, allows users to dynamically visualize the data, and produces downloadable reports. 0.1 Example Apps The following are some diverse examples of Shiny apps that the instructor has made. Plot Demo Simulate data from a 2×2 factorial design and visualize it with 6 different plot styles. Simulating for LMEM companion to Understanding mixed effects models through data simulation (DeBruine &amp; Barr, AMPPS 2021) Scienceverse is an ambitious (but in-progress) app for creating machine-readable descriptions of studies and human-readable summaries. Word Cloud Create a word cloud from text and customize its appearance. Created during the live-coding event at Hack Your Data Beautiful. Figure 0.1: Word Cloud App 0.2 Code Horizons Course (27-30 July 2021) Starting July 27, we are offering this seminar as a 4-day synchronous*, remote workshop for the first time. Each day will consist of a 3-hour live lecture held via the free video-conferencing software Zoom. You are encouraged to join the lecture live, but will have the opportunity to view the recorded session later if you are unable to attend at the scheduled time. Each lecture session will conclude with a hands-on exercise reviewing the content covered, to be completed on your own. An additional lab session will be held Tuesday and Thursday afternoons, where you can review the exercise results with the instructor and ask any questions. We understand that scheduling is difficult during this unpredictable time. If you prefer, you may take all or part of the course asynchronously. The video recordings will be made available within 24 hours of each session and will be accessible for two weeks after the seminar, meaning that you will get all of the class content and discussions even if you cannot participate synchronously. Closed captioning is available for all live and recorded sessions. 0.3 Computing To participate in the hands-on exercises, you are strongly encouraged to use a computer with the most recent version of R installed. Participants are also encouraged to download and install RStudio, a front-end for R that makes it easier to work with. This software is free and available for Windows, Mac, and Linux platforms. 0.4 Who Should Register? You need to have basic familiarity with R, including data import, data processing, visualization, and functions and control structures (e.g., if/else). Instruction will be done using RStudio. Some familiarity with ggplot2 and dplyr would be useful. You definitely do not need to be an expert coder, but the following code should not be challenging to understand. library(ggplot2) pets &lt;- read.csv(&quot;pets.csv&quot;) dv &lt;- sample(c(&quot;score&quot;, &quot;weight&quot;), 1) if (dv == &quot;score&quot;) { g &lt;- ggplot(pets, aes(pet, score, fill = country)) } else if (dv == &quot;weight&quot;) { g &lt;- ggplot(pets, aes(pet, weight, fill = country)) } r + geom_violin(alpha = 0.5) If you want to brush up on your R (especially tidyverse), and also gain familiarity with the instructor’s teaching style, the first seven chapters of Data Skills for Reproducible Science provide a good overview. 0.5 Glossary term definition data-wrangling The process of preparing data for visualisation and statistical analysis. function A named section of code that can be reused. rstudio An integrated development environment (IDE) that helps you process R code. shiny An R package that builds interactive web apps tidyverse A set of R packages that help you create and work with tidy data "],["getting-started.html", "Day 1 Getting Started 1.1 Your First Shiny App 1.2 ShinyDashboard", " Day 1 Getting Started 1.1 Your First Shiny App 1.1.1 Overview of the UI/server structure 1.1.2 Inputs, outputs, and action buttons 1.1.3 Reactive functions 1.2 ShinyDashboard 1.2.1 Basic template for shinydashboard projects 1.2.2 Sidebar, menu navigation, and tabs 1.2.3 Row- and column-based layouts "],["basic-patterns.html", "Day 2 Basic Patterns 2.1 Different input types 2.2 Different output types 2.3 Reading and saving data 2.4 Reactive functions", " Day 2 Basic Patterns Welcome to Day 2!. Today we’ll expand on what we learned in Day 1 to cover input and output in more depth. We’ll also learn how to read and write data to and from files. In the second half of Day 2, we’ll expand what we’ve learned about reactivity and practice some common reactive patterns. 2.1 Different input types Inputs are ways that users can communicate information to the Shiny app. Explore some different input types in the embedded app below before you read about how to set up each type. You can run this app locally with shinyintro::app(\"input_demo\"). Figure 2.1: Input Demo App 2.1.1 textInput textInput() creates a one-line box for short text input. demo_text &lt;- textInput(&quot;demo_text&quot;, label = &quot;Name&quot;, value = &quot;&quot;, width = &quot;100%&quot;, placeholder = &quot;Your Name&quot;) 2.1.2 textAreaInput textAreaInput() creates a multi-line box for longer text input. demo_textarea &lt;- textAreaInput(&quot;demo_textarea&quot;, label = &quot;Biography&quot;, value = &quot;&quot;, width = &quot;100%&quot;, rows = 5, placeholder = &quot;Tell us something interesting about you.&quot;) 2.1.3 selectInput sekectInput() creates a drop-down menu. Set the first choice to \"\" to default to NA. If your choices are a named list, the names are what is shown and the values are what is recorded. If the choices aren’t named, the displayed and recorded values are the same. demo_select &lt;- selectInput(&quot;demo_select&quot;, label = &quot;Do you like Shiny?&quot;, choices = list(&quot;&quot;, &quot;Yes, I do&quot; = &quot;y&quot;, &quot;No, I don&#39;t&quot; = &quot;n&quot;), selected = NULL, width = &quot;100%&quot;) You can also make a select where users can choose multiple options. genders &lt;- list( # no blank needed &quot;Non-binary&quot; = &quot;nb&quot;, &quot;Male&quot; = &quot;m&quot;, &quot;Female&quot; = &quot;f&quot;, &quot;Agender&quot; = &quot;a&quot;, &quot;Gender Fluid&quot; = &quot;gf&quot; ) demo_select_multi &lt;- selectInput(&quot;demo_select2&quot;, label = &quot;Gender (select all that apply)&quot;, choices = genders, selected = NULL, multiple = TRUE, selectize = FALSE, size = 5) 2.1.4 checkboxGroupInput However, this interface almost always looks better with a checkbox group. demo_cbgi &lt;- checkboxGroupInput(&quot;demo_cbgi&quot;, label = &quot;Gender (select all that apply)&quot;, choices = genders) 2.1.5 checkboxInput You can also make a single checkbox. The value is TRUE when checked and FALSE when not. demo_cb &lt;- checkboxInput(&quot;demo_cb&quot;, label = &quot;I love R&quot;, value = TRUE) Sliders allow you to choose numbers between a minimum and maximum. demo_slider &lt;- sliderInput(&quot;demo_slider&quot;, label = &quot;Age&quot;, min = 0, max = 100, value = 0, step = 1, width = &quot;100%&quot;) 2.1.6 Setting inputs programatically Sometimes you need to change the value of an input with code, such as when resetting a questionnaire or in response to an answer on another item. The following code reseats all of the inputs above. updateTextInput(session, &quot;demo_text&quot;, value = &quot;&quot;) updateTextAreaInput(session, &quot;demo_textarea&quot;, value = &quot;&quot;) updateSelectInput(session, &quot;demo_select&quot;, selected = &quot;&quot;) updateCheckboxGroupInput(session, &quot;demo_cbgi&quot;, selected = character(0)) updateCheckboxInput(session, &quot;demo_cb&quot;, value = TRUE) updateSliderInput(session, &quot;demo_slider&quot;, value = 0) Note that select inputs and checkbox groups use the argument selected and not value. If you want to set all the values in a checkbox group to unchecked, set selected = character(0). 2.2 Different output types Output are ways that the Shiny app can dynamically display information to the user. In the user interface (UI), you create outputs with IDs that you reference in and associated rendering function inside the server function. Explore some different output types in the embedded app below before you read about how to set up each type. You can run this app locally with shinyintro::app(\"output_demo\"). Figure 2.2: Output Demo App 2.2.1 textOutput The function textOutput() defaults to text inside a &lt;span&gt; or &lt;div&gt; element, but you can use a different element with the container argument. # in the UI textOutput(&quot;demo_text&quot;, container = tags$h3) # in the server function output$demo_text &lt;- renderText({ sprintf(&quot;Plot of %s&quot;, input$y) }) If you use verbatimTextOutput() in the UI (no change to the server function), it will show the output in a fixed-width font. This can be good for code or text you want the user to copy. # in the UI verbatimTextOutput(&quot;demo_verbatim&quot;) # in the server function output$demo_verbatim &lt;- renderText({ code &lt;- &quot;ggplot(iris, aes(x = Species, y = %s, color = Species)) + geom_violin(show.legend = FALSE) + stat_summary(show.legend = FALSE)&quot; sprintf(code, input$y) }) 2.2.2 uiOutput If you want to dynamically create parts of the user interface (UI), you can use uiOutput(). You can create the user interface using the input functions # in the UI uiOutput(&quot;demo_ui&quot;) # in the server function output$demo_ui &lt;- renderUI({ cols &lt;- names(iris)[1:4] selectInput(&quot;y&quot;, &quot;Column to plot&quot;, cols, &quot;Sepal.Length&quot;) }) The function htmlOutput() is exactly the same as uiOutput(), so you might see that in some code examples, but I use uiOutput() to make the connection with renderUI() clearer, since there is no renderHTML(). 2.2.3 plotOutput # in the UI plotOutput(&quot;demo_plot&quot;) # in the server function output$demo_plot &lt;- renderPlot({ ggplot(iris, aes(x = Species, y = .data[[input$y]], color = Species)) + geom_violin(show.legend = FALSE) + stat_summary(show.legend = FALSE) + ylab(input$y) }) If you want to create dynamic plots that change with input, note how you need to use y = .data[[input$y]] inside the aes() function, instead of just y = input$y. 2.2.4 imageOutput # in the UI imageOutput(&quot;demo_image&quot;) # in the server function output$demo_image &lt;- renderImage({ list(src = &quot;images/flower.jpg&quot;, width = 100, height = 100, alt = &quot;A flower&quot;) }, deleteFile = FALSE) You can dynamically display images of any type, but one of the most useful ways to use image outputs is to control the aspect ratio and relative size of plots. When you save a temporary file, you should set deleteFile = TRUE in the renderImage() function (this stops unneeded plots using memory). # in the UI imageOutput(&quot;demo_image&quot;) # in the server function output$demo_image &lt;- renderImage({ # make the plot g &lt;- ggplot(iris, aes(x = Species, y = .data[[input$y]], color = Species)) + geom_violin(show.legend = FALSE) + stat_summary(show.legend = FALSE) + ylab(input$y) # save to a temporary file plot_file &lt;- tempfile(fileext = &quot;.png&quot;) ggsave(plot_file, demo_plot(), units = &quot;in&quot;, dpi = 72, width = 7, height = 5) # Return a list containing the filename list(src = plot_file, width = &quot;100%&quot;, # don&#39;t set the height to keep aspect ratio alt = &quot;The plot&quot;) }, deleteFile = TRUE) 2.2.5 tableOutput The reanderTable() function will display a table from any data frame it returns. # in the UI tableOutput(&quot;demo_table&quot;) # in the server function output$demo_table &lt;- renderTable({ iris %&gt;% group_by(Species) %&gt;% summarise(mean = mean(.data[[input$y]]), sd = sd(.data[[input$y]])) }) Note how you need to use .data[[input$y]] inside the dplyr::summarise() function, instead of just input$y to dynamically choose which variable to summarise. 2.2.6 dataTableOutput If you have a long table to show, or one that you want users to be able to sort or search, use dataTableOutput(). You can customise data tables in many ways, but we’ll stick with a basic example here. # in the UI DT::dataTableOutput(&quot;demo_datatable&quot;) # in the server function output$demo_datatable &lt;- DT::renderDataTable({ iris }, options = list(pageLength = 10)) The basic shiny package has dataTableOutput() and renderDataTable() functions, but they can be buggy. The version in the DT package are better and have some additional functions, so I use those. 2.3 Reading and saving data 2.3.1 Local Data You can read and write data from a Shiny app the same way you do from any R script. We will focus on reading data, since writing data locally can cause problems and is better done with Google Sheets. The base directory for a Shiny app is the directory that app.R is in. I recommend keeping your data in a directory called “data” to keep things tidy. # read local data my_data &lt;- readxl::read_xls(&quot;data/my_data.xls&quot;) # read data on the web countries &lt;- readr::read_csv(&quot;https://datahub.io/core/country-list/r/data.csv&quot;) languages &lt;- jsonlite::read_json(&quot;https://datahub.io/core/language-codes/r/language-codes.json&quot;) 2.3.2 Google Sheets One of the best ways to start collecting data with a Shiny app is with Google Sheets. This allows you to collect data to the same place from multiple servers, which might happen if you’re running the app locally on more than one computer or through a service like shinyapps.io. The R package googlesheets4 makes it easy to work with Google Sheets from R. If you just want to read data from a public Google Sheet, you don’t need any authorisation. Just start your code with gs4_deauth() after you load the googlesheets4 library (otherwise you’ll be prompted to log in). Then you can read data like this: library(googlesheets4) gs4_deauth() sheet_id &lt;- &quot;https://docs.google.com/spreadsheets/d/1tQCYQrI4xITlPyxb9dQ-JpMDYeADovIeiZZRNHkctGA/&quot; read_sheet(sheet_id) number letter 1 A 2 B 3 C However, even if a Google Sheet is publicly editable, you can’t add data to it without authorising your account. data &lt;- data.frame(number = 4, letter = &quot;D&quot;) sheet_append(sheet_id, data) ## Error: Client error: (401) UNAUTHENTICATED ## * Request not authenticated due to missing, invalid, or expired OAuth token. ## * Request is missing required authentication credential. Expected OAuth 2 access token, login cookie or other valid authentication credential. See https://developers.google.com/identity/sign-in/web/devconsole-project. You can authorise interactively using the following code (and your own email), which will prompt you to authorise “Tidyverse API Packages” the first time you do this. gs4_auth(email = &quot;debruine@gmail.com&quot;) However, this won’t work if you want your Shiny apps to be able to access your Google Sheets. 2.3.2.1 Authorisation for Apps First, you need to get a token and store it in a cache folder in your app directory. We’re going to call that directory “.secrets.” Run the following code in your console (NOT in an Rmd file). This will open up a web browser window and prompt you to choose your Google account and authorise “Tidyverse API Packages.” setwd(app_directory) gs4_auth(email = &quot;debruine@gmail.com&quot;, cache = &quot;.secrets&quot;) # optionally, authorise google drive to search your drive # googledrive::drive_auth(email = &quot;debruine@gmail.com&quot;, cache = &quot;.secrets&quot;) Figure 2.3: Prompts to choose an account, grant permissions, and confirm. When you have finished, you will see a page that says something like, “Authentication complete. Please close this page and return to R.” In the file pane in RStudio, you should now see a directory. called “.secrets” in the app directory. If you are using GitHub, you don’t want to save your secret info to a public repository, so run the following code to ignore any directories called “.secrets” (so they will only exist on your computer and not on GitHub). usethis::use_git_ignore(&quot;.secrets&quot;) usethis::use_git_ignore(&quot;*/.secrets&quot;) Now, you can include the following code at the top of your app.R script to authorise the app to read from and write to your files. gs4_auth(cache = &quot;.secrets&quot;, email = &quot;debruine@gmail.com&quot;) 2.3.2.2 Accessing an existing sheet If you have an existing Google Sheet, you can access it by URL. sheet_id &lt;- &quot;https://docs.google.com/spreadsheets/d/1tQCYQrI4xITlPyxb9dQ-JpMDYeADovIeiZZRNHkctGA/&quot; data &lt;- data.frame(number = 4, letter = &quot;D&quot;) sheet_append(sheet_id, data) read_sheet(sheet_id) number letter 1 A 2 B 3 C 4 D 2.3.2.3 Make a new sheet You can set up a new Google Sheet with code. You only need to do this once for a sheet that you will use with a Shiny app, and you will need to save the sheet ID. If you don’t specify the tab name(s), the sheet will be created with one tab called “Sheet1.” I recommend making only one sheet per app and saving each table in a separate tab. id &lt;- gs4_create(&quot;demo2&quot;, sheets = c(&quot;demographics&quot;, &quot;questionnaire&quot;)) id ## Spreadsheet name: demo2 ## ID: 1PzgFVHJFDqQKSiK0cXnes6kqUML-f8nnRiXguFO1_KY ## Locale: en_US ## Time zone: Europe/London ## # of sheets: 2 ## ## (Sheet name): (Nominal extent in rows x columns) ## demographics: 1000 x 26 ## questionnaire: 1000 x 26 Include the ID at the top of your app like this: SHEET_ID 2.3.2.4 Add data You can add an empty data structure to your sheet by specifying the data types of each column like this: data &lt;- data.frame( name = character(0), birthyear = integer(0), parent = logical(0), score = double(0) ) write_sheet(data, SHEET_ID, &quot;demographics&quot;) read_sheet(SHEET_ID, &quot;demographics&quot;) %&gt;% names() ## [1] &quot;name&quot; &quot;birthyear&quot; &quot;parent&quot; &quot;score&quot; Or you can populate the table with starting data. data &lt;- data.frame( name = &quot;Lisa&quot;, birthyear = 1976L, R_user = TRUE, score = 10.2 ) write_sheet(data, SHEET_ID, &quot;demographics&quot;) read_sheet(SHEET_ID, &quot;demographics&quot;) name birthyear R_user score Lisa 1976 TRUE 10.2 Notice that birthyear is a double, not an integer. Google Sheets only have one numeric type, so both doubles and integers are coerced to doubles. 2.3.2.5 Appending Data Then you can append new rows of data to the sheet. data &lt;- data.frame( name = &quot;Robbie&quot;, birthyear = 2007, R_user = FALSE, score = 12.1 ) sheet_append(SHEET_ID, data, &quot;demographics&quot;) read_sheet(SHEET_ID, &quot;demographics&quot;) name birthyear R_user score Lisa 1976 TRUE 10.2 Robbie 2007 FALSE 12.1 If you try to append data of a different type, some weird things can happen. Logical values added to a numeric column are cast as 0 (FALSE) and 1 (TRUE), while numeric values added to a logical column change the column to numeric. If you mix character and numeric values in a column, the resulting column is a column of one-item lists so that each list can have the appropriate data type. (Data frames in R cannot mix data types in the same column.) data &lt;- data.frame( name = 1, birthyear = FALSE, R_user = 0, score = &quot;No&quot; ) sheet_append(SHEET_ID, data, &quot;demographics&quot;) read_sheet(SHEET_ID, &quot;demographics&quot;) name birthyear R_user score Lisa 1976 1 10.2 Robbie 2007 0 12.1 1 0 0 No You must append data that has the same number and order of columns as the Google Sheet. If you send columns out of order, they will be recorded in the order you sent them, not in the order of the column names. If you send extra columns, the append will fail. The Shiny template we’re working with has a safer version of sheet_append() that you can access by uncommenting the line: # source(\"R/sheet_append.R\") This version gracefully handles data with new columns, missing columns, columns in a different order, and columns with a different data type. However, it reads the whole data sheet before deciding whether to append or overwrite the data, which can slow down your app, so is best used only during development when you’re changing things a lot. Once you have the final structure of your data, it’s better to use the original googlesheets4::sheet_append() function. 2.4 Reactive functions "],["more-complex-apps.html", "Day 3 More Complex Apps 3.1 Customizing Your Apps 3.2 Intermediate Patterns", " Day 3 More Complex Apps 3.1 Customizing Your Apps 3.1.1 CSS, HTML, and Javascript 3.1.2 Structuring a complex app 3.2 Intermediate Patterns 3.2.1 Debugging and error handling 3.2.2 Displaying elements contingent on the state of other elements "],["sharing-your-apps.html", "Day 4 Sharing your Apps 4.1 Sharing Platforms 4.2 Advanced Patterns", " Day 4 Sharing your Apps 4.1 Sharing Platforms 4.1.1 shinyapps.io 4.1.2 Self-hosting a shiny server 4.1.3 GitHub 4.1.4 In an R package 4.2 Advanced Patterns 4.2.1 Creating and downloading a customized report 4.2.2 Shiny modules for repeated structures "]]
